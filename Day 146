class Solution {
    static int time;
    
    static ArrayList<Integer> articulationPoints(int V, int[][] edges) {
        // code here
      ArrayList<ArrayList<Integer>> adj = new ArrayList<>();
      for(int i = 0; i < V; i++) adj.add(new ArrayList<>());
      for(int[] e : edges) {
          adj.get(e[0]).add(e[1]);
          adj.get(e[1]).add(e[0]);
      }
      
      int[] disc = new int[V];
      int[] low = new int[V];
      boolean[] visited = new boolean[V];
      boolean[] isAP = new boolean[V];
      int[] parent = new int[V];
      Arrays.fill(parent, -1);
      
      time = 0;
      
      for(int i = 0; i < V; i++) {
          if(!visited[i]) {
              dfs(i, adj, visited, disc, low, parent, isAP);
          }
      }
      
      ArrayList<Integer> result = new ArrayList<>();
      for(int i = 0; i < V; i++) {
          if(isAP[i]) result.add(i);
      }
      if(result.isEmpty()) result.add(-1);
      return result;
    }
    
    static void dfs(int u, ArrayList<ArrayList<Integer>> adj, boolean[] visited, int[] disc, int[] low, int[] parent, boolean[] isAP) {
        visited[u] = true;
        disc[u] = low[u] = ++time;
        int children = 0;
        
        for(int v : adj.get(u)) {
            if(!visited[v]) {
                children++;
                parent[v] = u;
                dfs(v, adj, visited, disc, low, parent, isAP);
                
                low[u] = Math.min(low[u], low[v]);
                
                if(parent[u] == -1 && children > 1) {
                    isAP[u] = true;
                }
                
                if(parent[u] != -1 && low[v] >= disc[u]) {
                    isAP[u] = true;
                }
            }else if (v != parent[u]) {
                low[u] = Math.min(low[u], disc[v]);
            }
        }
    }
}
